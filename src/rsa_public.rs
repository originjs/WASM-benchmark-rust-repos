use super::*;

use std::str;

use rsa::pkcs8::{DecodePublicKey, EncodePublicKey, LineEnding};
use rsa::{PaddingScheme, PublicKey, RsaPublicKey};

use der::Document;
use sha2;

#[wasm_bindgen]
#[derive(Debug)]
pub struct RsaPublic {
    pub_instance: RsaPublicKey,
    pub_pem: String,
}

#[wasm_bindgen]
impl RsaPublic {
    #[wasm_bindgen(constructor)]
    // TODO: is n and e needed in struct?
    pub fn new(input_key_pem: String) -> Self {
        let pub_instance = RsaPublicKey::from_public_key_pem(&input_key_pem)
            .expect("Failed to read public key bytes!");
        let pub_pem = pub_instance
            .to_public_key_pem(LineEnding::default())
            .expect("Failed to transform key to pem!");

        Self {
            pub_instance,
            pub_pem,
        }
    }

    // TODO: add custom digest algo support for OAEP; now default is Sha256
    pub fn encrypt(&self, msg: &[u8], padding_scheme: &str) -> Vec<u8> {
        // default padding scheme: OAEP with sha256
        let padding = match padding_scheme {
            "PKCS1V15Encrypt" => PaddingScheme::new_pkcs1v15_encrypt(),
            "OAEP" => PaddingScheme::new_oaep::<sha2::Sha256>(),
            _ => PaddingScheme::new_oaep::<sha2::Sha256>(),
        };

        let mut rng = rand::thread_rng();

        self.pub_instance
            .encrypt(&mut rng, padding, &msg[..])
            .expect("Failed to encrypt the message!")
    }

    #[wasm_bindgen(js_name = getPublicKeyPem)]
    pub fn get_public_key_pem(&self) -> String {
        self.pub_pem.clone()
    }

    // TODO: der generated by this func cannot be verified by openssl
    #[wasm_bindgen(js_name = getPublicKeyDer)]
    pub fn get_public_key_der(&self) -> Vec<u8> {
        self.pub_instance
            .to_public_key_der()
            .expect("Failed to transform public key to der!")
            .to_der()
            .to_vec()
    }
}

#[cfg(test)]
mod rsa_public_tests {
    use super::*;
    use super::super::rsa_private::RsaPrivate;

    #[test]
    fn can_new_with_rsa_private() {
        let rsa_public = RsaPublic::new(RsaPrivate::new(Some(1024), None).get_public_key_pem());
        assert_eq!(rsa_public.pub_pem.is_empty(), false);
    }

    #[test]
    #[should_panic]
    fn cannot_new_with_empty_key() {
        RsaPublic::new(String::from(""));
    }

    #[test]
    fn can_get_public_key_content() {
        let rsa_pubic = RsaPublic::new(RsaPrivate::new(Some(1024), None).get_public_key_pem());
        assert_ne!(rsa_pubic.get_public_key_pem(), String::from(""));
        assert_ne!(rsa_pubic.get_public_key_der(), Vec::<u8>::new());
    }

    #[test]
    fn can_encrypt() {
        let rsa_pubic = RsaPublic::new(RsaPrivate::new(Some(1024), None).get_public_key_pem());
        assert_ne!(rsa_pubic.encrypt(b"secret", ""), Vec::<u8>::new());
    }
}