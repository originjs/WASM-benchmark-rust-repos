use std::collections::HashMap;

pub fn getSboxP() -> Vec<HashMap<u32, u32>> {
    let mut P: Vec<HashMap<u32, u32>> = Vec::new();
    let key0: Vec<u32> = vec![
        0x0, 0x10000000, 0x20000000, 0x30000000, 0x40000000, 0x50000000, 0x60000000, 0x70000000,
        0x80000000, 0x90000000, 0xa0000000, 0xb0000000, 0xc0000000, 0xd0000000, 0xe0000000,
        0xf0000000, 0x8000000, 0x18000000, 0x28000000, 0x38000000, 0x48000000, 0x58000000,
        0x68000000, 0x78000000, 0x88000000, 0x98000000, 0xa8000000, 0xb8000000, 0xc8000000,
        0xd8000000, 0xe8000000, 0xf8000000, 0x1, 0x10000001, 0x20000001, 0x30000001, 0x40000001,
        0x50000001, 0x60000001, 0x70000001, 0x80000001, 0x90000001, 0xa0000001, 0xb0000001,
        0xc0000001, 0xd0000001, 0xe0000001, 0xf0000001, 0x8000001, 0x18000001, 0x28000001,
        0x38000001, 0x48000001, 0x58000001, 0x68000001, 0x78000001, 0x88000001, 0x98000001,
        0xa8000001, 0xb8000001, 0xc8000001, 0xd8000001, 0xe8000001, 0xf8000001,
    ];
    let key1: Vec<u32> = vec![
        0x0, 0x1000000, 0x2000000, 0x3000000, 0x4000000, 0x5000000, 0x6000000, 0x7000000,
        0x8000000, 0x9000000, 0xa000000, 0xb000000, 0xc000000, 0xd000000, 0xe000000, 0xf000000,
        0x800000, 0x1800000, 0x2800000, 0x3800000, 0x4800000, 0x5800000, 0x6800000, 0x7800000,
        0x8800000, 0x9800000, 0xa800000, 0xb800000, 0xc800000, 0xd800000, 0xe800000, 0xf800000,
        0x10000000, 0x11000000, 0x12000000, 0x13000000, 0x14000000, 0x15000000, 0x16000000,
        0x17000000, 0x18000000, 0x19000000, 0x1a000000, 0x1b000000, 0x1c000000, 0x1d000000,
        0x1e000000, 0x1f000000, 0x10800000, 0x11800000, 0x12800000, 0x13800000, 0x14800000,
        0x15800000, 0x16800000, 0x17800000, 0x18800000, 0x19800000, 0x1a800000, 0x1b800000,
        0x1c800000, 0x1d800000, 0x1e800000, 0x1f800000,
    ];
    let key2: Vec<u32> = vec![
        0x0, 0x100000, 0x200000, 0x300000, 0x400000, 0x500000, 0x600000, 0x700000, 0x800000,
        0x900000, 0xa00000, 0xb00000, 0xc00000, 0xd00000, 0xe00000, 0xf00000, 0x80000, 0x180000,
        0x280000, 0x380000, 0x480000, 0x580000, 0x680000, 0x780000, 0x880000, 0x980000, 0xa80000,
        0xb80000, 0xc80000, 0xd80000, 0xe80000, 0xf80000, 0x1000000, 0x1100000, 0x1200000,
        0x1300000, 0x1400000, 0x1500000, 0x1600000, 0x1700000, 0x1800000, 0x1900000, 0x1a00000,
        0x1b00000, 0x1c00000, 0x1d00000, 0x1e00000, 0x1f00000, 0x1080000, 0x1180000, 0x1280000,
        0x1380000, 0x1480000, 0x1580000, 0x1680000, 0x1780000, 0x1880000, 0x1980000, 0x1a80000,
        0x1b80000, 0x1c80000, 0x1d80000, 0x1e80000, 0x1f80000,
    ];
    let key3: Vec<u32> = vec![
        0x0, 0x10000, 0x20000, 0x30000, 0x40000, 0x50000, 0x60000, 0x70000, 0x80000, 0x90000,
        0xa0000, 0xb0000, 0xc0000, 0xd0000, 0xe0000, 0xf0000, 0x8000, 0x18000, 0x28000, 0x38000,
        0x48000, 0x58000, 0x68000, 0x78000, 0x88000, 0x98000, 0xa8000, 0xb8000, 0xc8000, 0xd8000,
        0xe8000, 0xf8000, 0x100000, 0x110000, 0x120000, 0x130000, 0x140000, 0x150000, 0x160000,
        0x170000, 0x180000, 0x190000, 0x1a0000, 0x1b0000, 0x1c0000, 0x1d0000, 0x1e0000, 0x1f0000,
        0x108000, 0x118000, 0x128000, 0x138000, 0x148000, 0x158000, 0x168000, 0x178000, 0x188000,
        0x198000, 0x1a8000, 0x1b8000, 0x1c8000, 0x1d8000, 0x1e8000, 0x1f8000,
    ];
    let key4: Vec<u32> = vec![
        0x0, 0x1000, 0x2000, 0x3000, 0x4000, 0x5000, 0x6000, 0x7000, 0x8000, 0x9000, 0xa000,
        0xb000, 0xc000, 0xd000, 0xe000, 0xf000, 0x800, 0x1800, 0x2800, 0x3800, 0x4800, 0x5800,
        0x6800, 0x7800, 0x8800, 0x9800, 0xa800, 0xb800, 0xc800, 0xd800, 0xe800, 0xf800, 0x10000,
        0x11000, 0x12000, 0x13000, 0x14000, 0x15000, 0x16000, 0x17000, 0x18000, 0x19000, 0x1a000,
        0x1b000, 0x1c000, 0x1d000, 0x1e000, 0x1f000, 0x10800, 0x11800, 0x12800, 0x13800, 0x14800,
        0x15800, 0x16800, 0x17800, 0x18800, 0x19800, 0x1a800, 0x1b800, 0x1c800, 0x1d800, 0x1e800,
        0x1f800,
    ];
    let key5: Vec<u32> = vec![
        0x0, 0x100, 0x200, 0x300, 0x400, 0x500, 0x600, 0x700, 0x800, 0x900, 0xa00, 0xb00, 0xc00,
        0xd00, 0xe00, 0xf00, 0x80, 0x180, 0x280, 0x380, 0x480, 0x580, 0x680, 0x780, 0x880, 0x980,
        0xa80, 0xb80, 0xc80, 0xd80, 0xe80, 0xf80, 0x1000, 0x1100, 0x1200, 0x1300, 0x1400, 0x1500,
        0x1600, 0x1700, 0x1800, 0x1900, 0x1a00, 0x1b00, 0x1c00, 0x1d00, 0x1e00, 0x1f00, 0x1080,
        0x1180, 0x1280, 0x1380, 0x1480, 0x1580, 0x1680, 0x1780, 0x1880, 0x1980, 0x1a80, 0x1b80,
        0x1c80, 0x1d80, 0x1e80, 0x1f80,
    ];
    let key6: Vec<u32> = vec![
        0x0, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80, 0x90, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0,
        0xf0, 0x8, 0x18, 0x28, 0x38, 0x48, 0x58, 0x68, 0x78, 0x88, 0x98, 0xa8, 0xb8, 0xc8, 0xd8,
        0xe8, 0xf8, 0x100, 0x110, 0x120, 0x130, 0x140, 0x150, 0x160, 0x170, 0x180, 0x190, 0x1a0,
        0x1b0, 0x1c0, 0x1d0, 0x1e0, 0x1f0, 0x108, 0x118, 0x128, 0x138, 0x148, 0x158, 0x168, 0x178,
        0x188, 0x198, 0x1a8, 0x1b8, 0x1c8, 0x1d8, 0x1e8, 0x1f8,
    ];
    let key7: Vec<u32> = vec![
        0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x80000000,
        0x80000001, 0x80000002, 0x80000003, 0x80000004, 0x80000005, 0x80000006, 0x80000007,
        0x80000008, 0x80000009, 0x8000000a, 0x8000000b, 0x8000000c, 0x8000000d, 0x8000000e,
        0x8000000f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c,
        0x1d, 0x1e, 0x1f, 0x80000010, 0x80000011, 0x80000012, 0x80000013, 0x80000014, 0x80000015,
        0x80000016, 0x80000017, 0x80000018, 0x80000019, 0x8000001a, 0x8000001b, 0x8000001c,
        0x8000001d, 0x8000001e, 0x8000001f,
    ];
    let value0: Vec<u32> = vec![
        0x808200, 0x8000, 0x808002, 0x2, 0x200, 0x808202, 0x800202, 0x800000, 0x202, 0x800200,
        0x8200, 0x808000, 0x8002, 0x800002, 0x0, 0x8202, 0x0, 0x808202, 0x8202, 0x8000, 0x808200,
        0x200, 0x808002, 0x2, 0x800200, 0x8200, 0x808000, 0x800202, 0x800002, 0x8002, 0x202,
        0x800000, 0x8000, 0x2, 0x808200, 0x800000, 0x808002, 0x8200, 0x200, 0x800202, 0x808202,
        0x808000, 0x800002, 0x8202, 0x202, 0x800200, 0x8002, 0x0, 0x808202, 0x808000, 0x800000,
        0x200, 0x8000, 0x800002, 0x2, 0x8202, 0x8002, 0x800202, 0x202, 0x808200, 0x800200, 0x0,
        0x8200, 0x808002,
    ];
    let value1: Vec<u32> = vec![
        0x40084010, 0x4000, 0x80000, 0x40080010, 0x40000010, 0x40084000, 0x40004000, 0x10, 0x84000,
        0x40004010, 0x40000000, 0x84010, 0x80010, 0x0, 0x4010, 0x40080000, 0x40004000, 0x84010,
        0x10, 0x40004010, 0x40084010, 0x40000000, 0x80000, 0x40080010, 0x80010, 0x0, 0x4000,
        0x40080000, 0x40000010, 0x84000, 0x40084000, 0x4010, 0x0, 0x40080010, 0x40004010,
        0x40084000, 0x40080000, 0x10, 0x84010, 0x4000, 0x4010, 0x80000, 0x80010, 0x40000010,
        0x84000, 0x40004000, 0x40000000, 0x40084010, 0x84010, 0x80000, 0x40080000, 0x4000,
        0x40004000, 0x40084010, 0x10, 0x40000000, 0x40084000, 0x40000010, 0x40004010, 0x80010, 0x0,
        0x4010, 0x40080010, 0x84000,
    ];
    let value2: Vec<u32> = vec![
        0x104, 0x0, 0x4000100, 0x10104, 0x10004, 0x4000004, 0x4010104, 0x4010000, 0x4000000,
        0x4010100, 0x10100, 0x4010004, 0x4000104, 0x10000, 0x4, 0x100, 0x4010100, 0x4010004, 0x0,
        0x4000100, 0x4000004, 0x10000, 0x10004, 0x104, 0x4, 0x100, 0x4010000, 0x10104, 0x10100,
        0x4000104, 0x4010104, 0x4000000, 0x4010100, 0x10004, 0x10000, 0x4000100, 0x100, 0x4010104,
        0x4000004, 0x0, 0x4000104, 0x4000000, 0x4, 0x10100, 0x4010000, 0x104, 0x10104, 0x4010004,
        0x4000000, 0x104, 0x4010100, 0x0, 0x10004, 0x4000100, 0x100, 0x4010004, 0x10000, 0x4010104,
        0x10104, 0x4000004, 0x4000104, 0x4010000, 0x4, 0x10100,
    ];
    let value3: Vec<u32> = vec![
        0x80401000, 0x80001040, 0x401040, 0x80400000, 0x0, 0x401000, 0x80000040, 0x400040,
        0x80000000, 0x400000, 0x40, 0x80001000, 0x80400040, 0x1040, 0x1000, 0x80401040, 0x80001040,
        0x40, 0x80400040, 0x80001000, 0x401000, 0x80401040, 0x0, 0x80400000, 0x1000, 0x80401000,
        0x400000, 0x1040, 0x80000000, 0x400040, 0x401040, 0x80000040, 0x400040, 0x401000,
        0x80000040, 0x0, 0x1040, 0x80400040, 0x80401000, 0x80001040, 0x80401040, 0x80000000,
        0x80400000, 0x401040, 0x80001000, 0x400000, 0x40, 0x1000, 0x80400000, 0x80401040, 0x0,
        0x401000, 0x400040, 0x80000000, 0x80001040, 0x40, 0x80000040, 0x1000, 0x80001000,
        0x80400040, 0x1040, 0x80401000, 0x400000, 0x401040,
    ];
    let value4: Vec<u32> = vec![
        0x80, 0x1040000, 0x40000, 0x20000000, 0x20040080, 0x1000080, 0x21000080, 0x40080,
        0x1000000, 0x20040000, 0x20000080, 0x21040080, 0x21040000, 0x0, 0x1040080, 0x21000000,
        0x1040080, 0x21000080, 0x80, 0x1040000, 0x40000, 0x20040080, 0x21040000, 0x20000000,
        0x20040000, 0x0, 0x21040080, 0x1000080, 0x20000080, 0x21000000, 0x1000000, 0x40080,
        0x40000, 0x80, 0x20000000, 0x21000080, 0x1000080, 0x21040000, 0x20040080, 0x1000000,
        0x21040080, 0x21000000, 0x1040000, 0x20040000, 0x40080, 0x20000080, 0x0, 0x1040080,
        0x21000080, 0x1000000, 0x1040000, 0x20040080, 0x20000000, 0x1040080, 0x80, 0x21040000,
        0x40080, 0x21040080, 0x0, 0x21000000, 0x1000080, 0x40000, 0x20040000, 0x20000080,
    ];
    let value5: Vec<u32> = vec![
        0x10000008, 0x2000, 0x10200000, 0x10202008, 0x10002000, 0x200000, 0x200008, 0x10000000,
        0x0, 0x10002008, 0x202000, 0x8, 0x10200008, 0x202008, 0x2008, 0x10202000, 0x10200000,
        0x10202008, 0x8, 0x200000, 0x202008, 0x10000008, 0x10002000, 0x2008, 0x200008, 0x2000,
        0x10002008, 0x10200008, 0x0, 0x10202000, 0x202000, 0x10000000, 0x10002000, 0x10200008,
        0x10202008, 0x2008, 0x200000, 0x10000000, 0x10000008, 0x202000, 0x202008, 0x0, 0x8,
        0x10200000, 0x2000, 0x10002008, 0x10202000, 0x200008, 0x8, 0x202000, 0x200000, 0x10000008,
        0x10002000, 0x2008, 0x10202008, 0x10200000, 0x10202000, 0x10200008, 0x2000, 0x202008,
        0x200008, 0x0, 0x10000000, 0x10002008,
    ];
    let value6: Vec<u32> = vec![
        0x100000, 0x2000401, 0x400, 0x100401, 0x2100401, 0x0, 0x1, 0x2100001, 0x2000400, 0x100001,
        0x2000001, 0x2100400, 0x2100000, 0x401, 0x100400, 0x2000000, 0x2100001, 0x0, 0x2000401,
        0x2100400, 0x100000, 0x2000001, 0x2000000, 0x401, 0x100401, 0x2000400, 0x2100000, 0x100001,
        0x400, 0x2100401, 0x1, 0x100400, 0x2000000, 0x100000, 0x2000401, 0x2100001, 0x100001,
        0x2000400, 0x2100400, 0x100401, 0x401, 0x2100401, 0x100400, 0x1, 0x0, 0x2100000, 0x2000001,
        0x400, 0x100400, 0x2000401, 0x2100001, 0x1, 0x2000000, 0x100000, 0x401, 0x2100400,
        0x2000001, 0x2100000, 0x0, 0x2100401, 0x100401, 0x400, 0x2000400, 0x100001,
    ];
    let value7: Vec<u32> = vec![
        0x8000820, 0x20000, 0x8000000, 0x20, 0x20020, 0x8020820, 0x8020800, 0x800, 0x8020000,
        0x8000800, 0x20800, 0x8020020, 0x820, 0x0, 0x8000020, 0x20820, 0x800, 0x8020820, 0x8000820,
        0x8000000, 0x8020000, 0x20800, 0x20820, 0x20, 0x8000020, 0x820, 0x20020, 0x8020800, 0x0,
        0x8020020, 0x8000800, 0x20000, 0x20820, 0x8020800, 0x20, 0x800, 0x8000800, 0x8000020,
        0x8020020, 0x20000, 0x0, 0x20020, 0x8020000, 0x8000820, 0x8020820, 0x20800, 0x820,
        0x8000000, 0x20000, 0x800, 0x8020020, 0x20820, 0x20, 0x8020000, 0x8000000, 0x8000820,
        0x8020820, 0x8000020, 0x8000800, 0x0, 0x20800, 0x820, 0x20020, 0x8020800,
    ];
    let P0: HashMap<u32, u32> = key0.into_iter().zip(value0.into_iter()).collect();
    let P1: HashMap<u32, u32> = key1.into_iter().zip(value1.into_iter()).collect();
    let P2: HashMap<u32, u32> = key2.into_iter().zip(value2.into_iter()).collect();
    let P3: HashMap<u32, u32> = key3.into_iter().zip(value3.into_iter()).collect();
    let P4: HashMap<u32, u32> = key4.into_iter().zip(value4.into_iter()).collect();
    let P5: HashMap<u32, u32> = key5.into_iter().zip(value5.into_iter()).collect();
    let P6: HashMap<u32, u32> = key6.into_iter().zip(value6.into_iter()).collect();
    let P7: HashMap<u32, u32> = key7.into_iter().zip(value7.into_iter()).collect();
    P.push(P0);
    P.push(P1);
    P.push(P2);
    P.push(P3);
    P.push(P4);
    P.push(P5);
    P.push(P6);
    P.push(P7);

    P
}

pub fn getSboxMask() -> [u32; 8] {
    [
        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000, 0x0001f800, 0x00001f80, 0x000001f8,
        0x8000001f,
    ]
}

pub fn getSubKeys(keyWords: &[u32]) -> Vec<[u32; 8]> {
    let mut subKeys: Vec<[u32; 8]> = Vec::new();
    // Permuted Choice 1 constants
    let PC1: [u32; 56] = [
        57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3,
        60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45,
        37, 29, 21, 13, 5, 28, 20, 12, 4,
    ];

    // Permuted Choice 2 constants
    let PC2: [u32; 48] = [
        14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41,
        52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32,
    ];

    // Cumulative bit shift constants
    let BIT_SHIFTS: [u32; 16] = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];

    // Select 56 bits according to PC1
    let mut keyBits: [u32; 56] = [0; 56];
    for i in 0..56 {
        let mut keyBitPos: u32 = PC1[i] - 1;
        keyBits[i] = (keyWords[(keyBitPos >> 5) as usize] >> (31 - keyBitPos % 32)) & 1;
    }

    // Assemble 16 subkeys
    for nSubKey in 0..16 {
        // Create subkey
        let mut subKey: [u32; 8] = [0; 8];

        // Shortcut
        let bitShift = BIT_SHIFTS[nSubKey];

        // Select 48 bits according to PC2
        for i in 0..24 {
            // Select from the left 28 key bits
            subKey[(i / 6) | 0] |=
                keyBits[(((PC2[i] - 1) + bitShift) % 28) as usize] << (31 - i % 6);

            // Select from the right 28 key bits
            subKey[4 + ((i / 6) | 0)] |=
                keyBits[(28 + (((PC2[i + 24] - 1) + bitShift) % 28)) as usize] << (31 - i % 6);
        }

        // Since each subkey is applied to an expanded 32-bit input,
        // the subkey can be broken into 8 values scaled to 32-bits,
        // which allows the key to be used without expansion
        subKey[0] = (subKey[0] << 1) | (subKey[0] >> 31);
        for i in 1..7 {
            subKey[i] = subKey[i] >> ((i - 1) * 4 + 3);
        }
        subKey[7] = (subKey[7] << 5) | (subKey[7] >> 27);
        subKeys.push(subKey);
    }

    subKeys
}

pub fn getInvSubKeys(subKeys: &Vec<[u32; 8]>) -> Vec<[u32; 8]> {
    let mut invSubKeys: Vec<[u32; 8]> = Vec::new();
    for i in 0..16 {
        invSubKeys.push(subKeys[15 - i]);
    }

    invSubKeys
}
